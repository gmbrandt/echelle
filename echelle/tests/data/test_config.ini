[data]
# The data class to use for the data. The class must implement all of the methods of echelle.images.DataProduct
data_class = echelle.images.Image
# the extension number or name in the .fits file where the raw data for the exposure lies. Typically 0
# for non-compressed files, and 1 for .fits.fz files.
primary_data_extension = 1
# elements that must be contained in the filenames of the files to reduce. E.g. ['.fits', '20190405']
files_contain = ['.fits']
# the fits header keys which gives the frame `type` of the observation, the `gain` and the `read_noise`
header_keys = {'type': 'OBSTYPE',
               'gain': 'GAIN',
               'read_noise': 'RDNOISE'}
# the corresponding possible entries of 'type' and which ones correspond to wavecal and lampflat.
# format as a python dict.
type_keys = {'LAMPFLAT': 'lampflat',
             'DOUBLE': 'wavecal'}

[stages]
# Reduction stages for a wavelength calibration frame, in order.
wavecal = ['echelle.basic.OverscanSubtractor',
          'echelle.basic.GainNormalizer',
          'echelle.basic.Trimmer',
          'echelle.traces.LoadTrace',
          'echelle.extract.RectifyTwodSpectrum',
          'echelle.extract.BoxExtract',
          'echelle.fibers.IdentifyFibers',
          'echelle.blaze.BackgroundSubtractSpectrum',
          'echelle.blaze.ApplyBlaze',
          'echelle.wavelength.Initialize',
          'echelle.wavelength.AddWavelengthColumn',
          'echelle.wavelength.LoadReferenceLineList',
          'echelle.wavelength.IdentifyArcEmissionLinesLowSN',
          'echelle.wavelength.BlazeCorrectArcEmissionLines',
          'echelle.wavelength.FitOverlaps',
          'echelle.wavelength.IdentifyArcEmissionLines',
          #'echelle.wavelength.IdentifyPrincipleOrderNumber',
          'echelle.wavelength.SolveFromOverlaps',
          'echelle.wavelength.FindGlobalScale',
          'echelle.wavelength.SolutionRefineInitial',
          'echelle.wavelength.SolutionRefineFinal',
          'echelle.wavelength.IdentifyArcEmissionLinesLowSN',
          'echelle.wavelength.ApplyToSpectrum',
          'banzai_nres.wavelength.TabulateArcEmissionLines']

# reduction stages for lampflat file types, in order.
lampflat = ['echelle.basic.OverscanSubtractor',
            'echelle.basic.GainNormalizer',
            'echelle.basic.Trimmer',
            'echelle.traces.TraceMaker']

[reduction]
# settings for each reduction stage
# Trace settings #
TRACE_FIT_INITIAL_DEGREE_TWO_GUESS = 90
TRACE_FIT_POLYNOMIAL_ORDER = 4
TRACE_TABLE_NAME = 'TRACE'
# pixel window down the center of the detector to look for traces.
WINDOW_FOR_TRACE_IDENTIFICATION = {'max': 2100, 'min': 2000}
# minimum pixel spacing between two adjacent diffraction orders or fibers on the detector.
MIN_FIBER_TO_FIBER_SPACING = 10
MIN_SNR_FOR_TRACE_IDENTIFICATION = 6
# Blaze settings.
BLAZE_TABLE_NAME = 'BLAZE'
BLAZE_CORRECTED_BOX_SPECTRUM_NAME = 'BLZCBOX'
# Extraction settings #
# half windows are in pixels.
MAX_EXTRACTION_HALF_WINDOW = 10
BOX_EXTRACTION_HALF_WINDOW = 10
BOX_SPECTRUM_NAME = 'SPECBOX'

# order identification settings #
# reference id of the central diffraction order in the database arc template.
ref_id = 26

# Wavelength calibration settings #
OVERLAP_TABLE_NAME = 'OVERLAP'
EMISSION_LINES_TABLE_NAME = 'LINES'
max_red_overlap = 1000
max_blue_overlap = 2000
global_scale_range = (0.5, 1.5)
overlap_linear_scale_range = (0.5, 2)
approx_detector_range_angstroms = 5000
approx_num_orders = 67
# principle order number (m0) settings for the IdentifyPrincipleOrderNumber stage
# start (inclusive), stop (exclusive)
m0_range = (50, 54)
principle_order_number = 52
# the minimum number of overlaps which must be fit for the wavelength solution to proceed.
min_num_overlaps = 5
# the min signal to noise for an emission peak to be considered in the wavelength solution.
min_peak_snr = 10
# initial model that is constrained via the overlaps and is used to find the global scale:
initial_wavelength_model = {1: [0, 1, 2],
                            2: [0, 1, 2]}
# wavelength model for the initial refine stage:
intermediate_wavelength_model = {0: [0, 1, 2],
                                 1: [0, 1, 2],
                                 2: [0, 1, 2]}
# wavelength model that the final refine stage will end at (stage begins with the intermediate model):
final_wavelength_model = {0: [0, 1, 2, 3, 4, 5],
                          1: [0, 1, 2, 3, 4, 5],
                          2: [0, 1, 2, 3, 4, 5],
                          3: [0, 1, 2, 3, 4, 5],
                          4: [0]}
